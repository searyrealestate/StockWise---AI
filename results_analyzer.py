# results_analyzer.py

"""
Screener Results Backtester & Analyzer
======================================

This script provides the core simulation and analysis engine for verifying the
performance of "BUY" signals generated by a screener (like the AI Advisor or
MICO system).

Its main purpose is to take a list of potential trades, simulate them as if
they were executed, and then present a detailed dashboard of their
performance.

How it Works:
-------------
The script is not run directly but provides key functions for other modules:

1.  **`run_backtest(trades_df, ...)`**:
    -   This is the simulation engine. It iterates through each "BUY" signal
        provided in the `trades_df`.
    -   For each trade, it fetches the full historical data from the entry date
        onward.
    -   It simulates holding the trade day-by-day for a maximum of ~85 days.
    -   It checks for an exit condition:
        1.  **PASS (Take-Profit)**: If the day's high hits the profit target.
        2.  **FAILED (Stop-Loss)**: If the day's low hits the stop-loss.
        3.  **FAILED (Expired)**: If neither is hit within the time limit.
    -   It calculates the P/L % and actual P/L ($) for each trade.

2.  **`display_backtest_dashboard(results_df, ...)`**:
    -   This function renders a comprehensive dashboard in Streamlit.
    -   It calculates and displays high-level KPIs: Win Rate, Avg. Gain/Loss,
        Profit Factor, Total Trades, and Total P/L ($).
    -   It shows a detailed, line-by-line "Trade Log" of every simulated trade.
    -   It provides a dropdown to select a trade for visual analysis.

3.  **`create_trade_chart(trade_data, ...)`**:
    -   This generates a Plotly candlestick chart for a single selected trade.
    -   It clearly plots the Entry point, Exit point, Stop-Loss line, and
        Profit-Target line, allowing for easy visual verification of the
        trade's outcome.

Usage:
------
This script is intended to be imported by other parts of the application,
such as an optimizer or a results page, (e.g., `from results_analyzer import run_backtest`).
"""

import pandas as pd
import streamlit as st
import plotly.graph_objects as go
from data_source_manager import DataSourceManager
from utils import clean_raw_data
from datetime import datetime


def run_backtest(trades_df: pd.DataFrame, data_manager: DataSourceManager,
                 initial_portfolio_value: int = 100000, risk_per_trade_percent: float = 1.0):
    """
    Simulates trades based on screener recommendations and analyzes the results.
    """
    if trades_df.empty:
        st.warning("No trades to analyze.")
        return

    trade_results = []
    total_trades = len(trades_df)
    progress_bar = st.progress(0, text="Backtesting recommended trades...")

    # Calculate the dollar amount to risk per trade
    risk_per_trade_dollars = initial_portfolio_value * (risk_per_trade_percent / 100.0)

    # Get today's date ONCE, outside the loop
    today_str = datetime.now().strftime('%Y-%m-%d')

    for i, trade in trades_df.iterrows():
        symbol = trade['Symbol']
        entry_date = pd.to_datetime(trade['Analysis Date'])
        entry_price = trade['Entry Price']
        stop_loss = trade['Stop-Loss']
        profit_target = trade['Profit Target ($)']
        est_net_profit = trade['Est. Net Profit ($)']

        progress_bar.progress((i + 1) / total_trades, text=f"Analyzing {symbol}...")

        # --- NEW: Position Sizing ---
        per_share_risk = entry_price - stop_loss
        if per_share_risk <= 0:
            st.warning(f"Skipping {symbol}: Invalid risk (Entry: {entry_price}, SL: {stop_loss}).")
            continue

        num_shares = risk_per_trade_dollars / per_share_risk
        investment_amount = num_shares * entry_price  # This is now dynamic

        # Fetch historical data starting from the entry date
        df_raw = data_manager.get_stock_data(symbol, start_date=entry_date,end_date=today_str)

        # 1. Check if the DataFrame is empty
        # 2. Check if the index is a DatetimeIndex
        if df_raw.empty or not isinstance(df_raw.index, pd.DatetimeIndex):
            st.error(f"Data for {symbol} is invalid. Skipping.")
            continue

        # Filter data to the simulation period (entry date onwards)
        trade_period_df = df_raw[df_raw.index >= entry_date].copy()

        outcome = "Expired"
        exit_price = None
        exit_date = None

        # Simulate the trade over the next 60 trading days
        for current_exit_date, current_day in trade_period_df.iloc[1:].iterrows():   # Start from day after entry
            if (current_exit_date - entry_date).days > 85:  # Using calendar days is safer
                break

            # Check for stop-loss hit
            if current_day['low'] <= stop_loss:
                outcome = "FAILED (Stop-Loss)"
                exit_price = stop_loss
                exit_date = current_day.name
                break
            # Check for profit-target hit
            elif current_day['high'] >= profit_target:
                outcome = "PASS (Take-Profit)"
                exit_price = profit_target
                exit_date = current_day.name
                break

        if exit_price is None:
            # If trade expired, exit at the last known closing price
            exit_price = trade_period_df['close'].iloc[-1] if not trade_period_df.empty else entry_price
            exit_date = trade_period_df.index[-1] if not trade_period_df.empty else entry_date
            outcome = "FAILED (Expired)"

        pl_percent = ((exit_price - entry_price) / entry_price) * 100

        # --- Calculate P/L based on dynamic shares ---
        actual_profit_dollars = (exit_price - entry_price) * num_shares

        # --- Verification Logic ---
        actual_trade_df = trade_period_df.loc[entry_date:exit_date]
        max_price = actual_trade_df['high'].max() if not actual_trade_df.empty else entry_price
        min_price = actual_trade_df['low'].min() if not actual_trade_df.empty else entry_price
        status_indicator = "(+)" if pl_percent > 0 else "(-)"

        trade_results.append({
            "Symbol": symbol,
            "Status": status_indicator,
            "P/L %": pl_percent,
            "Outcome": outcome,
            "Entry Date": entry_date.strftime('%Y-%m-%d'),
            "Entry Price": entry_price,
            "Exit Date": exit_date.strftime('%Y-%m-%d'),
            "Exit Price": exit_price,
            "Stop-Loss": stop_loss,
            "Profit Target": profit_target,
            "Max Price": max_price,
            "Min Price": min_price,
            "Est. Net Profit ($)": est_net_profit,
            "Actual P/L ($)": actual_profit_dollars,
            "Shares": num_shares,  # Added for info
            "Investment ($)": investment_amount  # Added for info
        })

    progress_bar.empty()
    if not trade_results:
        st.error("Could not process any trades for backtesting.")
        return

    results_df = pd.DataFrame(trade_results)
    display_backtest_dashboard(results_df, data_manager, initial_portfolio_value)


def display_backtest_dashboard(results_df: pd.DataFrame, data_manager: DataSourceManager, initial_portfolio_value: int):
    """Renders the performance metrics and trade analysis UI."""
    st.markdown("---")
    st.header("ðŸ”¬ Backtest Analysis Results")

    # --- Performance Metrics ---
    st.subheader("Key Performance Metrics")

    wins = results_df[results_df['Outcome'].str.startswith("PASS")]
    losses = results_df[results_df['Outcome'].str.startswith("FAILED")]
    win_rate = (len(wins) / len(results_df)) * 100 if len(results_df) > 0 else 0
    avg_gain = wins['P/L %'].mean() if not wins.empty else 0
    avg_loss = losses['P/L %'].mean() if not losses.empty else 0
    profit_factor = wins['P/L %'].sum() / abs(losses['P/L %'].sum()) if not losses.empty and losses[
        'P/L %'].sum() != 0 else float('inf')

    total_profit_dollars = results_df['Actual P/L ($)'].sum()

    # --- Add Portfolio Metrics ---
    final_portfolio_value = initial_portfolio_value + total_profit_dollars
    total_return_percent = (total_profit_dollars / initial_portfolio_value) * 100

    col1, col2, col3, col4, col5 = st.columns(5)
    col1.metric("Win Rate", f"{win_rate:.2f}%")
    col2.metric("Profit Factor", f"{profit_factor:.2f}")
    col3.metric("Total P/L ($)", f"{total_profit_dollars:.2f}")
    col4.metric("Total Return %", f"{total_return_percent:.2f}%")
    col5.metric("Final Portfolio ($)", f"{final_portfolio_value:.2f}")

    # --- Trade Log & Chart Visualization ---
    st.subheader("Trade Log & Verification")

    # Reordered columns for better readability with new data
    display_cols = [
        "Symbol", "Status", "P/L %", "Outcome", "Entry Date", "Entry Price",
        "Exit Date", "Exit Price", "Stop-Loss", "Profit Target",
        "Shares", "Investment ($)", "Actual P/L ($)"
    ]
    st.dataframe(results_df[display_cols].style.format({
        "P/L %": "{:.2f}%", "Entry Price": "${:.2f}", "Exit Price": "${:.2f}",
        "Stop-Loss": "${:.2f}", "Profit Target": "${:.2f}",
        "Shares": "{:.2f}", "Investment ($)": "${:,.2f}",
        "Actual P/L ($)": "${:,.2f}"
    }), use_container_width=True)

    st.subheader("Visual Trade Analysis")
    selected_trade_symbol = st.selectbox("Select a trade to visualize:", options=results_df['Symbol'].unique(),
                                         key="trade_chart_selector")
    if selected_trade_symbol:
        trade_to_plot = results_df[results_df['Symbol'] == selected_trade_symbol].iloc[0]
        fig = create_trade_chart(trade_to_plot, data_manager)
        st.plotly_chart(fig, use_container_width=True)


def create_trade_chart(trade_data: pd.Series, data_manager: DataSourceManager):
    """Generates a Plotly chart visualizing a single simulated trade."""
    symbol = trade_data['Symbol']
    entry_date = pd.to_datetime(trade_data['Entry Date'])
    exit_date = pd.to_datetime(trade_data['Exit Date'])

    chart_start_date = entry_date - pd.Timedelta(days=30)
    chart_end_date = exit_date + pd.Timedelta(days=10)
    df = data_manager.get_stock_data(symbol, start_date=chart_start_date, end_date=chart_end_date)
    fig = go.Figure(data=[go.Candlestick(x=df.index, open=df['open'], high=df['high'],
                                         low=df['low'], close=df['close'], name='Price')])
    fig.add_trace(go.Scatter(x=[entry_date], y=[trade_data['Entry Price']], mode='markers',
                             marker=dict(color='blue', size=12, symbol='circle'), name='Entry'))
    fig.add_hline(y=trade_data['Stop-Loss'], line_dash="dash", line_color="red", name="Stop-Loss")
    fig.add_hline(y=trade_data['Profit Target'], line_dash="dash", line_color="green", name="Profit Target")

    exit_marker_symbol = 'star-diamond' if trade_data['P/L %'] > 0 else 'x'
    exit_marker_color = 'green' if trade_data['P/L %'] > 0 else 'red'

    fig.add_trace(go.Scatter(x=[exit_date], y=[trade_data['Exit Price']], mode='markers',
                             marker=dict(color=exit_marker_color, size=14, symbol=exit_marker_symbol), name='Exit'))
    fig.update_layout(title=f"Trade Analysis for {symbol} ({trade_data['Outcome']})", xaxis_rangeslider_visible=False,
                      legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1))
    return fig
