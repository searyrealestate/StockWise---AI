# results_analyzer.py

"""
Screener Results Backtester & Analyzer
======================================

This script provides the core simulation and analysis engine for verifying the
performance of "BUY" signals generated by a screener (like the AI Advisor or
MICO system).

Its main purpose is to take a list of potential trades, simulate them as if
they were executed, and then present a detailed dashboard of their
performance.

How it Works:
-------------
The script is not run directly but provides key functions for other modules:

1.  **`run_backtest(trades_df, ...)`**:
    -   This is the simulation engine. It iterates through each "BUY" signal
        provided in the `trades_df`.
    -   For each trade, it fetches the full historical data from the entry date
        onward.
    -   It simulates holding the trade day-by-day for a maximum of ~85 days.
    -   It checks for an exit condition:
        1.  **PASS (Take-Profit)**: If the day's high hits the profit target.
        2.  **FAILED (Stop-Loss)**: If the day's low hits the stop-loss.
        3.  **FAILED (Expired)**: If neither is hit within the time limit.
    -   It calculates the P/L % and actual P/L ($) for each trade.

2.  **`display_backtest_dashboard(results_df, ...)`**:
    -   This function renders a comprehensive dashboard in Streamlit.
    -   It calculates and displays high-level KPIs: Win Rate, Avg. Gain/Loss,
        Profit Factor, Total Trades, and Total P/L ($).
    -   It shows a detailed, line-by-line "Trade Log" of every simulated trade.
    -   It provides a dropdown to select a trade for visual analysis.

3.  **`create_trade_chart(trade_data, ...)`**:
    -   This generates a Plotly candlestick chart for a single selected trade.
    -   It clearly plots the Entry point, Exit point, Stop-Loss line, and
        Profit-Target line, allowing for easy visual verification of the
        trade's outcome.

Usage:
------
This script is intended to be imported by other parts of the application,
such as an optimizer or a results page, (e.g., `from results_analyzer import run_backtest`).
"""

import pandas as pd
import streamlit as st
import plotly.graph_objects as go
from data_source_manager import DataSourceManager
from utils import clean_raw_data


def run_backtest(trades_df: pd.DataFrame, data_manager: DataSourceManager, investment_amount: int = 1000):
    """
    Simulates trades based on screener recommendations and analyzes the results.
    """
    if trades_df.empty:
        st.warning("No trades to analyze.")
        return

    trade_results = []
    total_trades = len(trades_df)
    progress_bar = st.progress(0, text="Backtesting recommended trades...")

    for i, trade in trades_df.iterrows():
        symbol = trade['Symbol']
        entry_date = pd.to_datetime(trade['Analysis Date'])
        entry_price = trade['Entry Price']
        stop_loss = trade['Stop-Loss']
        profit_target = trade['Profit Target ($)']
        est_net_profit = trade['Est. Net Profit ($)']

        progress_bar.progress((i + 1) / total_trades, text=f"Analyzing {symbol}...")

        # Fetch historical data starting from the entry date
        df_raw = data_manager.get_stock_data(symbol, start_date=entry_date)

        # 1. Check if the DataFrame is empty
        # 2. Check if the index is a DatetimeIndex
        if df_raw.empty or not isinstance(df_raw.index, pd.DatetimeIndex):
            st.error(f"Data for {symbol} is invalid. Skipping.")
            continue

        # Filter data to the simulation period (entry date onwards)
        trade_period_df = df_raw[df_raw.index >= entry_date].copy()

        outcome = "Expired"
        exit_price = None
        exit_date = None

        # Simulate the trade over the next 60 trading days
        for current_exit_date, current_day in trade_period_df.iloc[1:].iterrows():   # Start from day after entry
            if (current_exit_date - entry_date).days > 85:  # Using calendar days is safer
                break

            # Check for stop-loss hit
            if current_day['low'] <= stop_loss:
                outcome = "FAILED (Stop-Loss)"
                exit_price = stop_loss
                exit_date = current_day.name
                break
            # Check for profit-target hit
            elif current_day['high'] >= profit_target:
                outcome = "PASS (Take-Profit)"
                exit_price = profit_target
                exit_date = current_day.name
                break

        if exit_price is None:
            # If trade expired, exit at the last known closing price
            exit_price = trade_period_df['close'].iloc[-1] if not trade_period_df.empty else entry_price
            exit_date = trade_period_df.index[-1] if not trade_period_df.empty else entry_date
            outcome = "FAILED (Expired)"

        pl_percent = ((exit_price - entry_price) / entry_price) * 100

        actual_profit_dollars = (pl_percent / 100) * investment_amount

        # --- Verification Logic ---
        actual_trade_df = trade_period_df.loc[entry_date:exit_date]
        max_price = actual_trade_df['high'].max() if not actual_trade_df.empty else entry_price
        min_price = actual_trade_df['low'].min() if not actual_trade_df.empty else entry_price
        status_indicator = "(+)" if pl_percent > 0 else "(-)"

        trade_results.append({
            "Symbol": symbol,
            "Status": status_indicator,
            "P/L %": pl_percent,
            "Outcome": outcome,
            "Entry Date": entry_date.strftime('%Y-%m-%d'),
            "Entry Price": entry_price,
            "Exit Date": exit_date.strftime('%Y-%m-%d'),
            "Exit Price": exit_price,
            "Stop-Loss": stop_loss,
            "Profit Target": profit_target,
            "Max Price": max_price,
            "Min Price": min_price,
            "Est. Net Profit ($)": est_net_profit,
            "Actual P/L ($)": actual_profit_dollars
        })

    progress_bar.empty()
    if not trade_results:
        st.error("Could not process any trades for backtesting.")
        return

    results_df = pd.DataFrame(trade_results)
    display_backtest_dashboard(results_df, data_manager)


def display_backtest_dashboard(results_df: pd.DataFrame, data_manager: DataSourceManager):
    """Renders the performance metrics and trade analysis UI."""
    st.markdown("---")
    st.header("ðŸ”¬ Backtest Analysis Results")

    # --- Performance Metrics ---
    st.subheader("Key Performance Metrics")

    wins = results_df[results_df['Outcome'].str.startswith("PASS")]
    losses = results_df[results_df['Outcome'].str.startswith("FAILED")]
    win_rate = (len(wins) / len(results_df)) * 100 if len(results_df) > 0 else 0
    avg_gain = wins['P/L %'].mean() if not wins.empty else 0
    avg_loss = losses['P/L %'].mean() if not losses.empty else 0
    profit_factor = wins['P/L %'].sum() / abs(losses['P/L %'].sum()) if not losses.empty and losses[
        'P/L %'].sum() != 0 else float('inf')

    total_profit_dollars = results_df['Actual P/L ($)'].sum()

    col1, col2, col3, col4, col5 = st.columns(5)
    col1.metric("Win Rate", f"{win_rate:.2f}%")
    col2.metric("Avg. Gain / Loss", f"{avg_gain:.2f}% / {avg_loss:.2f}%")
    col3.metric("Profit Factor", f"{profit_factor:.2f}")
    col4.metric("Total Trades", f"{len(results_df)}")
    col5.metric("Total Profit ($)", f"{total_profit_dollars:.2f}")

    # --- Trade Log & Chart Visualization ---
    st.subheader("Trade Log & Verification")

    # Reordered columns for better readability with new data
    display_cols = [
        "Symbol", "Status", "P/L %", "Outcome", "Entry Date", "Entry Price",
        "Exit Date", "Exit Price", "Stop-Loss", "Profit Target", "Max Price", "Min Price", "Est. Net Profit ($)"
        , "Actual P/L ($)"
    ]
    st.dataframe(results_df[display_cols].style.format({
        "P/L %": "{:.2f}%", "Entry Price": "${:.2f}", "Exit Price": "${:.2f}",
        "Stop-Loss": "${:.2f}", "Profit Target": "${:.2f}",
        "Max Price": "${:.2f}", "Min Price": "${:.2f}",
        "Est. Net Profit ($)": "${:.2f}",
        "Actual P/L ($)": "${:.2f}"
    }), use_container_width=True)

    st.subheader("Visual Trade Analysis")
    selected_trade_symbol = st.selectbox("Select a trade to visualize:", options=results_df['Symbol'].unique(),
                                         key="trade_chart_selector")
    if selected_trade_symbol:
        trade_to_plot = results_df[results_df['Symbol'] == selected_trade_symbol].iloc[0]
        fig = create_trade_chart(trade_to_plot, data_manager, full_trade_row=trade_to_plot)
        st.plotly_chart(fig, use_container_width=True)


def create_trade_chart(trade_data: pd.Series, data_manager: DataSourceManager, full_trade_row: pd.Series = None):
    """Generates a Plotly chart visualizing a single simulated trade."""
    symbol = trade_data['Symbol']
    entry_date = pd.to_datetime(trade_data['Entry Date'])
    exit_date = pd.to_datetime(trade_data['Exit Date'])

    chart_start_date = entry_date - pd.Timedelta(days=250)
    chart_end_date = exit_date + pd.Timedelta(days=10)
    df = data_manager.get_stock_data(symbol, start_date=chart_start_date, end_date=chart_end_date)
    fig = go.Figure(data=[go.Candlestick(x=df.index, open=df['open'], high=df['high'],
                                         low=df['low'], close=df['close'], name='Price')])

    # --- Add Mico System Lines ---
    if full_trade_row is not None and full_trade_row.get('Source') == 'MICO':
        # Add Mico SMAs
        if len(df) >= 50:
            sma_50 = df['close'].rolling(50).mean()
            fig.add_trace(
                go.Scatter(x=df.index, y=sma_50, mode='lines', name='SMA 50', line=dict(color='blue', width=1)))
        if len(df) >= 200:
            sma_200 = df['close'].rolling(200).mean()
            fig.add_trace(
                go.Scatter(x=df.index, y=sma_200, mode='lines', name='SMA 200', line=dict(color='purple', width=1)))

        # Add Mico Stop-Loss and Profit-Target Lines
        fig.add_hline(y=trade_data['Stop-Loss'], line_dash="dash", line_color="red", name="Mico Stop-Loss")
        fig.add_hline(y=trade_data['Profit Target'], line_dash="dash", line_color="green", name="Mico Profit Target")
    else:
        # --- AI trades logic ---
        fig.add_hline(y=trade_data['Stop-Loss'], line_dash="dash", line_color="red", name="Stop-Loss")
        fig.add_hline(y=trade_data['Profit Target'], line_dash="dash", line_color="green", name="Profit Target")

    # Add Entry Marker
    fig.add_trace(go.Scatter(x=[entry_date], y=[trade_data['Entry Price']], mode='markers',
                             marker=dict(color='blue', size=12, symbol='circle'), name='Entry'))

    fig.add_hline(y=trade_data['Stop-Loss'], line_dash="dash", line_color="red", name="Stop-Loss")
    fig.add_hline(y=trade_data['Profit Target'], line_dash="dash", line_color="green", name="Profit Target")

    # Chart will now correctly show the icon based on P/L %
    exit_marker_symbol = 'star-diamond' if trade_data['P/L %'] > 0 else 'x'
    exit_marker_color = 'green' if trade_data['P/L %'] > 0 else 'red'

    fig.add_trace(go.Scatter(x=[exit_date], y=[trade_data['Exit Price']], mode='markers',
                             marker=dict(color=exit_marker_color, size=14, symbol=exit_marker_symbol), name='Exit'))
    fig.update_layout(title=f"Trade Analysis for {symbol} ({trade_data['Outcome']})", xaxis_rangeslider_visible=False,
                      legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1))
    return fig



# def create_trade_chart(trade_data: pd.Series, data_manager: DataSourceManager, full_trade_row: pd.Series = None):
#     """Generates a Plotly chart visualizing a single simulated trade."""
#     symbol = trade_data['Symbol']
#     entry_date = pd.to_datetime(trade_data['Entry Date'])
#     exit_date = pd.to_datetime(trade_data['Exit Date'])
#
#     # Use a wider date range to ensure SMAs are calculated
#     chart_start_date = entry_date - pd.Timedelta(days=250)
#     chart_end_date = exit_date + pd.Timedelta(days=10)
#     df = data_manager.get_stock_data(symbol, start_date=chart_start_date, end_date=chart_end_date)
#
#     fig = go.Figure(data=[go.Candlestick(x=df.index, open=df['open'], high=df['high'],
#                                          low=df['low'], close=df['close'], name='Price')])
#
#     # --- NEW: Add Mico System Lines ---
#     if full_trade_row is not None and full_trade_row.get('Source') == 'MICO':
#         # Add Mico SMAs
#         if len(df) >= 50:
#             sma_50 = df['close'].rolling(50).mean()
#             fig.add_trace(
#                 go.Scatter(x=df.index, y=sma_50, mode='lines', name='SMA 50', line=dict(color='blue', width=1)))
#         if len(df) >= 200:
#             sma_200 = df['close'].rolling(200).mean()
#             fig.add_trace(
#                 go.Scatter(x=df.index, y=sma_200, mode='lines', name='SMA 200', line=dict(color='purple', width=1)))
#
#         # Add Mico Stop-Loss and Profit-Target Lines (which are already in trade_data)
#         fig.add_hline(y=trade_data['Stop-Loss'], line_dash="dash", line_color="red", name="Mico Stop-Loss")
#         fig.add_hline(y=trade_data['Profit Target'], line_dash="dash", line_color="green", name="Mico Profit Target")
#     else:
#         # --- This is the OLD logic, which runs for AI trades ---
#         fig.add_hline(y=trade_data['Stop-Loss'], line_dash="dash", line_color="red", name="Stop-Loss")
#         fig.add_hline(y=trade_data['Profit Target'], line_dash="dash", line_color="green", name="Profit Target")
#     # --- END NEW ---
#
#     # Add Entry Marker
#     fig.add_trace(go.Scatter(x=[entry_date], y=[trade_data['Entry Price']], mode='markers',
#                              marker=dict(color='blue', size=12, symbol='circle'), name='Entry'))
#
#     # Chart will now correctly show the icon based on P/L %
#     exit_marker_symbol = 'star-diamond' if trade_data['P/L %'] > 0 else 'x'
#     exit_marker_color = 'green' if trade_data['P/L %'] > 0 else 'red'
#
#     fig.add_trace(go.Scatter(x=[exit_date], y=[trade_data['Exit Price']], mode='markers',
#                              marker=dict(color=exit_marker_color, size=14, symbol=exit_marker_symbol), name='Exit'))
#
#     # Set the x-axis range to focus on the trade
#     zoom_start_date = entry_date - pd.Timedelta(days=30)
#     fig.update_layout(
#         title=f"Trade Analysis for {symbol} ({trade_data['Outcome']})",
#         xaxis_rangeslider_visible=False,
#         legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
#         xaxis_range=[zoom_start_date, chart_end_date]  # Focus the chart on the trade
#     )
#
#     # Use template from session state for dark/light mode
#     if st.session_state.get('template', 'plotly_dark') == 'plotly_dark':
#         fig.update_layout(template="plotly_dark")
#     else:
#         fig.update_layout(template="plotly_white")
#
#     return fig